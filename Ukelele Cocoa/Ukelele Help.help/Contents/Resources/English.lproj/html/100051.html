<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"Simple Help Editor 5.0">
<meta http-equiv="Content-Type" content=
"text/html; charset=utf-8" />
<title>How does a keyboard layout work?</title>
<link href="../styles.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="98%">
<tr>
<td>This is a somewhat simplified picture of how a key press is
processed by the operating system. There are many variables, but
this should give you an idea of how it works.<br />
<br />
When a key is pressed on a keyboard, it generates a low-level
<span class="Style1">event</span>. This event includes the
<span class="Style1">key code</span> for the key that is pressed,
and the <span class="Style1">modifiers</span> that are in effect.
The operating system has the first look at this event, and may
handle it itself, mainly if the key is a special one, such as a
hardware control key (brightness control, sound, media eject). If
it does so, that is the end of it.<br />
<br />
If the operating system does not handle the key press directly, it
then passes on a higher-level event. At this point, the key code
becomes a <span class="Style1">virtual key code</span>. That is
generally the same as the key code, but the fn key can transform
the key, e.g. from return (key code 36) to enter (key code 76), so
that the virtual key code is different to the actual key
code.<br />
<br />
At this point, the operating system looks at the new event and
decides whether it is a menu equivalent, such as ⌘P for Print, or a
shortcut or hot key (as defined in System Preferences), such as F9
for Mission Control. If so, it performs whatever action is
required, which may be at the operating system level (e.g. Mission
Control), or sending an action message to the current application
(e.g. Print). Again, that is the end of the key press event.<br />
<br />
If the key press has still not been handled, it is passed to the
current application. The application can choose to handle it either
as a key press of some sort, or as a <span class="Style1">text
input event</span>. Often, games look at it as a key press, so that
pressing the right arrow key means to move forward, and ignore the
characters generated by the keyboard layout.<br />
<br />
If it is taken as a text input event, the operating system looks at
the keyboard layout. It takes the current dead key state, then
looks at the virtual key code and the current modifiers, and
generates a text input event with the characters defined by the
keyboard layout.<br />
<br />
There is one more element of complexity with menu equivalents and
shortcuts. Some applications look at the character that the
keyboard layout generates as the basis for the matching. So, if you
press ⌘w on a standard English keyboard, and the keyboard layout is
Dvorak, the actual character should be a comma, so would get the
equivalent of ⌘, (Preferences in many applications). However, some
other applications try to be clever and look at what the character
generated by the keyboard layout would be if the command key were
not pressed. This can lead to unexpected results, but is hopefully
not a widespread phenomenon these days.
<p class="navlinks"><span class="navlinks"><a href=
"100000.html">Next page</a></span></p>
</td>
</tr>
</table>
</body>
</html>
